Прай спешит на помощь¹
======================

| Проект:        | [Энту́ру](https://www.github.com/kyrylo/entooru/)
|:---------------|:------------------------------------------------
| Автор:         | Конрад Ирвин <conrad.irwin@gmail.com>
| Дата:          | 27 августа 2012 года
| URI:           | [http://cirw.in/blog/pry-to-the-rescue][0]
| Перевел:       | Кирилл Силин <kyrylosilin@gmail.com>
| Дата перевода: | 27 августа 2012 года


Введение: [прай-рэскью][pr] (прим. пер.: по-английски это выглядит как
_pry-rescue_. Далее я буду использовать именно транскрипцию): супер-быстрая,
безболезненная отладка для народных масс (рубистов).

Что оно делает?
---------------

Всякий раз, когда в вашей программе появляется необработанное исключение,
_прай-рэскью_ открывает интерактивную оболочку [Прай][pry] в точке, где оно было
вызвано. Вместо безрадостного разглядывания трассировки стека, выплюнотой
умирающим процессом, вы будете взаимодействовать с вашей программой так, как
будто бы она еще жива!

Консоль Прай дает вам доступ к методу, который вызвал это исключение. Вы можете
использовать её для изучения значений переменных (больше не нужны принты!),
исходного кода методов (больше не нужно метаться туда-сюда в текстовом
редакторе!) и даже двигаться вверх и вниз по стеку вызовов (прямо как настоящий
отладчик!).

Поскольку оболочка открывается так, как если бы исключение только-только
собиралось вызываться, то вам даже не нужно перезапускать вашу программу с
самого начала для того, чтобы начать отладку. Всё подогнано для работы в стиле
«исключения случаются».

Ладно, звучит здорово, как мне это использовать?
------------------------------------------------

Легко: `gem install pry-rescue pry-stack_explorer`, а затем запускайте свою
программу, используя `rescue foo.rb` вместо `ruby foo.rb`. Если `rescue` вам не
по нутру, тогда просто оборачивайте куски вашей программы в `Pry::rescue{ }`.
Любые необработанные исключения внутри этого блока будут для вас пойманы Праем
(скоро будет связка Рэком (англ. rack)).

Когда Прай открывается по причине исключения, у вас есть два выбора: нажать
&lt;Ctrl-d&gt;, чтобы позволить исключению случиться или же начать отладку! Если
вы выбираете последний путь, то для решения проблемы вам предоставляется вся
мощь Прая; опосля введите `try-again`, чтобы проверить, сработало ли решение.

Э-м… а есть какой-то пример?
----------------------------

Конечно! Давайте представим, что я написал какой-то код:

```ruby
def find_capitalized(a)
  a.select do |name|
    name.chars.first == name.chars.first.upcase
  end
end
```

Теперь я запускаю этот код: `rescue rescue.rb`

```
From: rescue.rb @ line 2 Object#find_capitalized:

    2: def find_capitalized(a)
    3:   a.select do |name|
 => 4:     name.chars.first == name.chars.first.upcase
    5:   end
    6: end

NoMethodError: undefined method `chars' for :direction:Symbol
from rescue.rb:4:in `block in find_capitalized'
[1] pry(main)>
```

Ага, что-то пошло не так. Но я хотя бы могу видеть, почему. Давайте поднимемся
вверх стека с помощью `up` и посмотрим, сможем ли мы выявить, что за код
вызывает этот метод с символами.

```
[1] pry(main)> up
From: rescue.rb @ line 8 Object#extract_people:

     8: def extract_people(opts)
 =>  9:   name_keys = find_capitalized(opts.keys)
    10: 
    11:   name_keys.each_with_object({}) do |name, o|
    12:     o[name] = opts.delete name
    13:   end
    14: end

[2] pry(main)> opts
=> {"Arthur"=>"Dent", :direction=>:left}
```

Так, это выглядит весьма странно. Ну да ладно, давайте посмотрим, есть ли более
лучший способ реализации метода `find_capitalized`:

```
[6] pry(main)> edit-method
[7] pry(main)> whereami
From: rescue.rb @ line 2 Object#find_capitalized:

    2: def find_capitalized(a)
 => 3:   a.select do |name|
    4:     name.capitalize == name
    5:   end
    6: end

[8] pry(main)> try-again
Arthur Dent moves left
```

<aside>Если вы хотите поработать с этим примером самостоятельно, то просто
склонируйте `https://github.com/ConradIrwin/pry-rescue`, и затем запустите
`rescue examples/rescue.rb`</aside>

Что мне необходимо знать еще?
-----------------------------

Ну, существует бесчисленное количество команд Прая, которые помогают в отладке:
`wtf?` и `cat --ex` могут быть использованы для исследования трассировки стека
и примыкающего к нему кода; `cd` и `ls` могут быть использованы для
пристального изучения объектов; `$` и `edit-method` могут быть использованы для
просмотра и редактирования исходного кода. Самым же полезным будет написать
`help` после установки Прая.

Другая полезная команда _прая-рэскью_ — это `cd-cause`. Она позволяет перемотать
назад предыдущее вызванное исключение. Так что если вы поймали одно исключение,
а затем вызвали другое (да, так бывает…) вы можете перепрыгнуть обратно к
первоначальной причине проблемы.

Помимо этого, единственное что еще вас может заинтересовать — это то, что вы
можете использовать `Pry::rescue{ }` вместе с исключениями, которые вы
обрабатываете самостоятельно. Просто вызовите `Pry::rescued(e)` в вашем блоке
`rescue`.

Итак, теперь установите джем: `gem install pry-rescue`. Если вы испытываете
трудности, тогда пожалуйста, дайте мне об этом знать на [Гитхабе][pr].

¹«Прай спешит на помощь» — это игра слов. Перевести точно эту фразу не
представляется возможным. Попробую объяснить, в чем же каламбур. Название
предмета статьи — это джем с названием «_pry-rescue_» В заголовке обыгрывается
привычная фраза «_to the rescue_» (спешить на помощь), намекая при этом на
название джема. (прим. пер.)

[0]: http://cirw.in/blog/pry-to-the-rescue
[pr]: https://github.com/ConradIrwin/pry-rescue
[pry]: http://pryrepl.org/
